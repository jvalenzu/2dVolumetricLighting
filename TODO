[x] setup header dependencies
[x] setup a render texture target
[x] use GLSL to do an image effect
[x] 2d raymarching
[x] 1d raymarching
[x] Material properties: initialize once with name and type, set via index, test type
[x] SceneObjectDestroy should remove any group association
[x] Textures into SimpleAssetManager
[x] SDF lighting
[x] sprite pivot points
[x] multiple light support
   The actual light data is straight-forward - separate arrays for point, directional, spotlight.  The interface for getting them up seems to be
   1) generate a uniform buffer object.  We would have one per light type.
   2) use glBindBuffer and glMapBuffer/glUnmapBuffer to copy the data once per frame.
   3) glGetUniformBlockIndex and glBindBufferBase to bind the UBO to a particular buffer location in the shader
   
   The structure of the runtime code deserves some thought.  Currently scene objects only comprise one scene object type.  If we want sprites to also be lights, we either need a spritelight type, we need each scene object to optionally also be a light, we need some componenty thing (ugh), or a way to attach scene objects (ugh).
[x] Light types
  [x] Point
  [x] Conical
  [x] Cylindrical (distance from line)
  Cylindrical light parameterization is kind of a mess.  m_Direction?  In screenspace?  But not really?
[x] Attenuation
  [x] Point
  [x] Conical
  [x] Cylindrical (distance from line)
[x] sprite scale
[x] sprite tint
[✓] shadows from multiple lights
  [x] Point
  [x] Conical
  Simplest way for non-point lights would be to do attentuation in the 1d phase.
  [x] 1st: multipass
  [ ] 2nd: texture array?
[✓] imgui layer to describe keys, toggle options like disabling lights and changing resolution
  [x] Add support to toggle individual lights.  Maybe just enable one at a time.
  [x] Change radius of point light
  [x] Change color of point light
  [x] Change color of cylinder
  [x] Change length of cylinder
  [x] Change length, color, angle of conical light
[x] rework conical attenuation.  Calculate two ranges, along facing and parallel to.  Parallel attenuation is squared.
[x] light prepass optimization
[x] directional light
[x] Add member function for MaterialReserveMaterialProperties
[x] Add member function for MaterialSetMaterialPropertyType
[x] Add member function for MaterialSetMaterialPropertyVector
[x] Add member function for MaterialSetMaterialPropertyFloat
[x] Add member function for MaterialSetMaterialPropertyTexture
[ ] ARTIFACT: The volumetric shadow has lines in it
[ ] ARTIFACT: Dealing with lsp embedded in occluder
[ ] ghost shadow?
[x] ARTIFACT: Dealing with nearly offscreen LSP -> radial test artifacts
[x] ambient parameterization
  - removed ambient in favor of directional lights, might want it back.
[x] query the default resolution to create an appropriately sized window.
[x] black screen after resize
[x] pare down RMath to just the stuff we need to generate Obb, then fix the types to R3
[✓] FIX ASPECT RATIO.  It's clearly wrong in all the screen space stuff.
  - Kludges in place to paper over problems.
  - Maybe instead of operating on fragmentPos, transform cylinder position and direction into aspect corrected clip space and separate aspect corrected fragment pos to use?
[x] debug cylindrical attenuation
[ ] move inline matrix methods into separate header.  Just to keep it more readable.
[ ] Remove standalone matrix functions where it makes sense, maybe MatrixMultiply.  Just rely on operator overloading.
[ ] Write README.md
[ ] Multiple LSPs

------------------------------------------------
PUBLISH
------------------------------------------------

[ ] Makefile dependency if you delete a source file (just hangs currently)
[ ] MRT for lsp raymarch generation.  Maybe simpler?
[✓] Windows port
  [x] OpenGL
  [ ] DirectX 11 or 12.
[✓] shader preprocessing
  [ ] Deal with different configurations (DEBUG, RELEASE, OSX, ETC)
  [ ] shader variations
  [ ] suppress MCPP warning from unrecognized #extension directive
  [ ] Shader variants to get back to one SampleShadowMap shader
[ ] relocate asset file paths
[ ] SceneObject reference count
[ ] sprite asset
[ ] Material assets
  [ ] Include normal data for SDF
[ ] UI legend describing keys
[ ] add member function for vec3 for destructive operations
[ ] movement less jerky
[ ] more comprehensive testing for memory leaks
[ ] shader reloading
[ ] shader fallback when a shader can't be compiled or found instead of crashing
[ ] use explicit layout in shaders to avoid string based coupling
[ ] move model matrix param setting into model, out of material
[ ] set view/projection param once per frame (or once per camera)
[ ] realtime SDF (CL)
[ ] move camera out of RenderContext and into Scene
[ ] move SceneObject instances over to HandleAssetManager
[ ] Parameterized shadow blend factor
[ ] Reverse index hashes in ShaderManager to allow sorting on separate indices
[ ] GNU/Linux port
[ ] GUIDs instead of asset paths
[ ] split one-time initialization like ShaderInit out of RenderInit which because it takes a render context implies it's not a singleton.  Alternatively make RenderContext a singleton.
[ ] make gamma correct
[ ] bilinear filter Gaussian blur to reduce number of passes
[ ] Shader assets
  [ ] Decouple vsh/fsh
[ ] hundreds of sprites
[ ] FIXME:
  [ ] duplication in ToolGenerateObbFromVec3 (Tools/Utils.cpp)
[ ] need to spell out how the FromZeroOne functions result in non-cartesean reactions in the 1d mapping functions

------------------------------------------------
DISTANT FUTURE
------------------------------------------------
[ ] Is glLogicOp still okay method to or in light bits?
[ ] Better method of finding eigenvectors in Obb tool
[ ] Do we need a separate Model Po matrix?  Seems like overkill given the size and purpose of the demo.
